// Min-Bisection (equal-size cut) on an undirected graph G = (V,E).
// Choose a partition V = A ∪ B with |A| = |B| = N/2 minimizing # crossing edges.

problem MinBisection {
  set V;
  set E;

  // Endpoints of each undirected edge e ∈ E (u,v).
  // Instance must ensure U[e] != W[e] and both are elements of V.
  param U[E] : Elem(V);
  param W[E] : Elem(V);

  // Decision: which side each vertex belongs to.
  // Interpret Side.has(v) = true  => v in A, else v in B.
  find Side : Subset(V);

  // Enforce equal-size partition: exactly N/2 vertices on Side=true.
  // Requires N even; N is size(V).
  // Instead of division by 2, we can equivalently sum 2 for each vertex on the side, and require that to equal N.

  must
    //sum(if Side.has(v) then 2 else 0 for v in V) = size(V);
    count(v in V where Side.has(v)) * 2 = size(V);

  // Minimize number of edges crossing the cut:
  // an edge contributes 1 iff endpoints are on different sides.
  //
  // This nested-if form is equivalent to XOR, but compiles compactly in backend-v1
  // because it avoids boolean reification (`and`/`or`) in the objective.
  minimize
    sum(
      if Side.has(U[e]) then
        if Side.has(W[e]) then 0 else 1
      else
        if Side.has(W[e]) then 1 else 0
      for e in E
    );
}
